<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D —Å–∏–º—É–ª—è—Ç–æ—Ä –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–≤—Ç–æ–º–æ–±–∏–ª—å–Ω–æ–≥–æ —Ä–µ–ª–µ (–¥–≤–∞ —Ä–µ–ª–µ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <style>
        body { margin:0; overflow:hidden; font-family:Arial,sans-serif; background:linear-gradient(135deg,#2c3e50,#1a1a2e); }
        canvas {
            display:block;
            outline:none;
            touch-action: none;
        }
        /* –í–µ—Ä—Ö–Ω—è—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–∞–Ω–µ–ª—å */
        #info-panel {
            position:absolute;
            top:10px;
            left:10px;
            right:10px;
            background:rgba(0,0,0,0.8);
            color:#fff;
            padding:12px;
            border-radius:8px;
            z-index:100;
            box-shadow:0 4px 12px rgba(0,0,0,0.5);
            border:1px solid #444;
            pointer-events: none;
            text-align:center;
            max-width:500px;
            margin:0 auto;
        }
        #info-panel h2 {
            margin:0 0 8px 0;
            font-size:1.2rem;
        }
        #info-panel .status-row {
            display:flex;
            justify-content:space-around;
            flex-wrap:wrap;
            gap:10px;
            margin:8px 0;
        }
        #info-panel .status-item {
            background:rgba(255,255,255,0.1);
            padding:6px 12px;
            border-radius:20px;
            font-size:0.9rem;
        }
        #info-panel .status-value {
            font-weight:bold;
            margin-left:5px;
        }
        #connection-status {
            padding:8px;
            border-radius:5px;
            font-weight:bold;
            margin-top:8px;
        }
        .on { background:#2ecc71; }
        .off { background:#e74c3c; }
        .faulty { background:#f39c12; color:#000; }

        /* –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å —Å –∫–Ω–æ–ø–∫–∞–º–∏ */
        #bottom-bar {
            position:absolute;
            bottom:10px;
            left:10px;
            right:10px;
            display:flex;
            justify-content:center;
            gap:15px;
            z-index:200;
            pointer-events: none;
        }
        #bottom-bar button {
            pointer-events: auto;
            background:#3498db;
            color:#fff;
            border:none;
            padding:14px 25px;
            border-radius:40px;
            cursor:pointer;
            font-weight:bold;
            font-size:16px;
            box-shadow:0 4px 8px rgba(0,0,0,0.3);
            transition:background 0.2s;
            flex:1;
            max-width:200px;
        }
        #bottom-bar button.reset {
            background:#e74c3c;
        }
        #bottom-bar button.reset:hover {
            background:#c0392b;
        }
        #bottom-bar button.hint:hover {
            background:#2980b9;
        }

        /* –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä–æ–π (—Å—Ç—Ä–µ–ª–∫–∏) */
        #camera-controls {
            position:absolute;
            bottom:90px;
            right:15px;
            display:grid;
            grid-template-columns: repeat(3, 60px);
            grid-gap:8px;
            background:rgba(0,0,0,0.6);
            padding:12px;
            border-radius:60px;
            backdrop-filter:blur(5px);
            z-index:250;
            pointer-events: none;
        }
        #camera-controls button {
            pointer-events: auto;
            width:60px;
            height:60px;
            background:rgba(255,255,255,0.2);
            border:2px solid rgba(255,255,255,0.5);
            color:white;
            font-size:28px;
            font-weight:bold;
            border-radius:40px;
            display:flex;
            align-items:center;
            justify-content:center;
            cursor:pointer;
            transition:0.2s;
            box-shadow:0 2px 5px rgba(0,0,0,0.3);
        }
        #camera-controls button:active {
            background:rgba(255,255,255,0.4);
            transform:scale(0.95);
        }
        #camera-controls .zoom-in { grid-column:2; }
        #camera-controls .zoom-out { grid-column:2; }

        /* –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø–æ–¥—Å–∫–∞–∑–∫–∏/—Å—Ö–µ–º—ã */
        #modal {
            position:absolute;
            top:50%;
            left:50%;
            transform:translate(-50%,-50%);
            background:rgba(30,30,40,0.98);
            color:#fff;
            padding:25px;
            border-radius:20px;
            box-shadow:0 10px 30px rgba(0,0,0,0.8);
            z-index:1000;
            width:85%;
            max-width:450px;
            max-height:80vh;
            overflow-y:auto;
            text-align:center;
            backdrop-filter:blur(10px);
            border:1px solid #555;
            display:none;
            pointer-events: auto;
        }
        #modal h3 {
            margin-top:0;
            color:#ffaa00;
        }
        #modal .content {
            margin:20px 0;
            line-height:1.6;
            font-size:16px;
        }
        #modal .button-group {
            display:flex;
            justify-content:space-around;
            gap:15px;
            margin-top:20px;
        }
        #modal button {
            background:#3498db;
            color:#fff;
            border:none;
            padding:14px 20px;
            border-radius:40px;
            font-weight:bold;
            font-size:16px;
            cursor:pointer;
            transition:0.2s;
            flex:1;
        }
        #modal button.secondary {
            background:#555;
        }
        #modal button.secondary:hover {
            background:#666;
        }
        #modal button.back {
            background:#f39c12;
        }
        #modal button.back:hover {
            background:#e67e22;
        }
        #modal ul {
            text-align:left;
            padding-left:20px;
        }
        #modal li {
            margin:10px 0;
        }

        /* –°–∫—Ä—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–µ –Ω–µ–Ω—É–∂–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã */
        #instructions, #drag-hint, #drag-info {
            display: none !important;
        }
        #hint {
            display: none;
        }
    </style>
</head>
<body>
    <!-- –í–µ—Ä—Ö–Ω—è—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–∞–Ω–µ–ª—å -->
    <div id="info-panel">
        <h2>üîß –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ–º–æ–±–∏–ª—å–Ω–æ–≥–æ —Ä–µ–ª–µ (–¥–≤–∞ —Ä–µ–ª–µ)</h2>
        <div class="status-row">
            <div class="status-item">–õ–∞–º–ø–∞: <span id="lamp-status" class="status-value">–í—ã–∫–ª</span></div>
            <div class="status-item">–†–µ–ª–µ 1 (–∏—Å–ø—Ä.): <span id="relay1-status" class="status-value">–ù–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ</span></div>
            <div class="status-item">–†–µ–ª–µ 2 (–Ω–µ–∏—Å–ø—Ä.): <span id="relay2-status" class="status-value">–ù–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ</span></div>
        </div>
        <div id="connection-status" class="off">–¶–µ–ø—å –Ω–µ –∑–∞–º–∫–Ω—É—Ç–∞</div>
    </div>

    <!-- –ù–∏–∂–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ -->
    <div id="bottom-bar">
        <button class="hint" id="show-hint-btn">üìã –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫—É</button>
        <button class="reset" id="reset-btn">üîÑ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è</button>
    </div>

    <!-- –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä–æ–π (—Å—Ç—Ä–µ–ª–∫–∏) -->
    <div id="camera-controls">
        <button class="move-up" id="cam-up">‚ñ≤</button>
        <button class="move-left" id="cam-left">‚óÄ</button>
        <button class="move-right" id="cam-right">‚ñ∂</button>
        <button class="move-down" id="cam-down">‚ñº</button>
        <button class="zoom-in" id="cam-zoom-in">+</button>
        <button class="zoom-out" id="cam-zoom-out">‚àí</button>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ -->
    <div id="modal">
        <div id="modal-content"></div>
        <div id="modal-buttons" class="button-group"></div>
    </div>

    <script>
        (function() {
            // --- –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ---
            let scene, camera, renderer, controls;
            let battery, lamp;
            let relay1, relay2; // –¥–≤–∞ —Ä–µ–ª–µ
            let relay1Light, relay2Light; // –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
            let clips = [];
            let wires = [];
            let activeClip = null;
            let activeMovable = null;
            let raycaster, mouse;
            let isMouseDown = false;
            let isDragging = false;
            let isDraggingMovable = false;
            let isInteracting = false;
            let dragPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 1);
            let dragOffset = new THREE.Vector3();
            let intersectPoint = new THREE.Vector3();
            let hoveredClip = null;
            let hoveredMovable = null;
            let hoveredTerminal = null;
            let originalMaterials = new WeakMap();
            let originalMovablePos = new THREE.Vector3();
            let font = null;

            // –§–ª–∞–≥–∏ –Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–æ—Å—Ç–∏: relay1 –∏—Å–ø—Ä–∞–≤–µ–Ω, relay2 –Ω–µ–∏—Å–ø—Ä–∞–≤–µ–Ω
            const RELAY1_FAULTY = false;
            const RELAY2_FAULTY = true;

            // --- –ö–ª–∞—Å—Å –ó–∞–∂–∏–º (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---
            class Clip {
                constructor(color, index, endType) {
                    this.group = new THREE.Group();
                    this.index = index;
                    this.endType = endType;
                    this.color = color;
                    this.connected = false;
                    this.connectedTerminal = null;
                    this.wire = null;

                    const mat = new THREE.MeshPhongMaterial({ color, shininess:100 });
                    const base = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.1,0.4), mat);
                    base.userData.isClipPart = true;
                    this.group.add(base);

                    for (let i=0; i<3; i++) {
                        const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.4), mat);
                        tooth.position.set(-0.1+i*0.1, -0.1, 0);
                        tooth.userData.isClipPart = true;
                        this.group.add(tooth);
                    }
                    const handle = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.1,0.2), mat);
                    handle.position.set(0.3, 0.1, 0);
                    handle.userData.isClipPart = true;
                    this.group.add(handle);

                    // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ —Å—Ç–æ–ª–µ (–Ω–µ–º–Ω–æ–≥–æ —Å–º–µ—Å—Ç–∏–º, —á—Ç–æ–±—ã —É–º–µ—Å—Ç–∏—Ç—å –¥–≤–∞ —Ä–µ–ª–µ)
                    if (index === 0) {
                        if (endType === 'start') this.group.position.set(-4.5,1,-2);
                        else { this.group.position.set(-3.5,1,-2); this.group.rotation.y = Math.PI; }
                    } else {
                        this.group.position.set(-5 + index*1.5, 1, -2);
                    }

                    this.group.userData = { type:'clip', clipObject:this };
                    this.homePos = this.group.position.clone();
                    scene.add(this.group);
                }
                setWire(w) { this.wire = w; }
                connectToTerminal(term) {
                    this.connected = true;
                    this.connectedTerminal = term;
                    const wp = new THREE.Vector3();
                    term.getWorldPosition(wp);
                    this.group.position.copy(wp);
                    this.group.position.y += 0.15;
                    if (this.wire) this.wire.updateGeometry();
                }
                disconnect() {
                    this.connected = false;
                    this.connectedTerminal = null;
                    this.group.position.copy(this.homePos);
                    if (this.wire) this.wire.updateGeometry();
                }
                highlight() { this.group.traverse(c => { if(c.isMesh) c.material.emissive = new THREE.Color(0x555555); }); }
                unhighlight() { this.group.traverse(c => { if(c.isMesh) c.material.emissive = new THREE.Color(0x000000); }); }
            }

            // --- –ö–ª–∞—Å—Å –ü—Ä–æ–≤–æ–¥ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---
            class Wire {
                constructor(startClip, endClip, color) {
                    this.startClip = startClip;
                    this.endClip = endClip;
                    this.color = color;

                    const geom = new THREE.CylinderGeometry(0.08, 0.08, 1, 8);
                    const mat = new THREE.MeshPhongMaterial({ color, emissive:0x222222 });
                    this.mesh = new THREE.Mesh(geom, mat);
                    this.mesh.userData.type = 'wire';
                    this.mesh.castShadow = true;
                    this.mesh.receiveShadow = true;

                    startClip.setWire(this);
                    endClip.setWire(this);

                    this.updateGeometry();
                    scene.add(this.mesh);
                }
                updateGeometry() {
                    if (!this.mesh) return;
                    this.startClip.group.updateMatrixWorld(true);
                    this.endClip.group.updateMatrixWorld(true);
                    
                    const startPos = new THREE.Vector3();
                    const endPos = new THREE.Vector3();
                    this.startClip.group.getWorldPosition(startPos);
                    this.endClip.group.getWorldPosition(endPos);

                    const dist = startPos.distanceTo(endPos);
                    if (dist < 0.01) {
                        this.mesh.scale.y = 0.01;
                        this.mesh.position.copy(startPos);
                        return;
                    }
                    const center = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);

                    this.mesh.position.copy(center);
                    this.mesh.lookAt(endPos);
                    this.mesh.rotateX(Math.PI/2);
                    this.mesh.scale.y = dist;
                }
            }

            // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã ---
            function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a2e);
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.set(0,5,12);
                renderer = new THREE.WebGLRenderer({ antialias:true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
                controls.enableTouch = false;

                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                const ambient = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambient);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(10,20,15);
                dirLight.castShadow = true;
                scene.add(dirLight);

                const table = new THREE.Mesh(
                    new THREE.BoxGeometry(20,0.5,20),
                    new THREE.MeshPhongMaterial({ color:0x8B4513, shininess:30 })
                );
                table.position.y = -0.25;
                table.receiveShadow = true;
                scene.add(table);

                // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
                createBattery();
                createRelay1(); // –∏—Å–ø—Ä–∞–≤–Ω–æ–µ
                createRelay2(); // –Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–æ–µ
                createLamp();
                createClipsAndWires();

                const loader = new THREE.FontLoader();
                loader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json',
                    f => { font = f; addTextLabels(); },
                    undefined,
                    e => console.warn('–®—Ä–∏—Ñ—Ç –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω, —Ç–µ–∫—Å—Ç –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è', e)
                );

                const grid = new THREE.GridHelper(20,20,0x555555,0x333333);
                scene.add(grid);

                renderer.domElement.addEventListener('pointerdown', onPointerDown);
                renderer.domElement.addEventListener('pointermove', onPointerMove);
                renderer.domElement.addEventListener('pointerup', onPointerUp);
                renderer.domElement.addEventListener('pointercancel', onPointerUp);
                renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

                // –ö–Ω–æ–ø–∫–∏
                document.getElementById('reset-btn').addEventListener('click', resetConnections);
                document.getElementById('show-hint-btn').addEventListener('click', showHintModal);
                document.getElementById('cam-up').addEventListener('click', () => moveCamera('up'));
                document.getElementById('cam-down').addEventListener('click', () => moveCamera('down'));
                document.getElementById('cam-left').addEventListener('click', () => moveCamera('left'));
                document.getElementById('cam-right').addEventListener('click', () => moveCamera('right'));
                document.getElementById('cam-zoom-in').addEventListener('click', () => zoomCamera('in'));
                document.getElementById('cam-zoom-out').addEventListener('click', () => zoomCamera('out'));

                // –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
                document.getElementById('modal').addEventListener('click', (e) => e.stopPropagation());

                animate();
            }

            function createBattery() {
                const g = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(2,1,1), new THREE.MeshPhongMaterial({ color:0x222222, shininess:50 }));
                body.castShadow = true;
                body.userData.isBody = true;
                g.add(body);

                const posTerm = createTerminal(0xff3333);
                posTerm.position.set(1.2,0.5,0);
                posTerm.userData = { type:'terminal', label:'battery_plus', connectedClips:[] };
                g.add(posTerm);

                const negTerm = createTerminal(0x3366ff);
                negTerm.position.set(-1.2,0.5,0);
                negTerm.userData = { type:'terminal', label:'battery_minus', connectedClips:[] };
                g.add(negTerm);

                g.position.set(-5,0.5,-2);
                g.rotation.y = Math.PI/2;
                g.userData = { movable:true, type:'movable', label:'battery' };
                scene.add(g);
                battery = g;
            }

            function createRelay1() { // –∏—Å–ø—Ä–∞–≤–Ω–æ–µ (—Å–µ—Ä–æ–µ)
                const g = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.5,0.8,1.5), new THREE.MeshPhongMaterial({ color:0x666666, shininess:70 }));
                body.castShadow = true;
                body.userData.isBody = true;
                g.add(body);

                // –ú–∞—Ä–∫–∏—Ä–æ–≤–∫–∞ "1"
                const markerMat = new THREE.MeshPhongMaterial({ color:0xffaa00 });
                const marker = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.1,0.1), markerMat);
                marker.position.set(0,0.5,0.8);
                g.add(marker);

                const labels = ['85','86','87','30'];
                const colors = [0x3366ff,0xff3333,0xff3333,0xff3333];
                const positions = [[-0.5,0.4,-0.5],[0.5,0.4,-0.5],[0.5,0.4,0.5],[-0.5,0.4,0.5]];
                for(let i=0;i<4;i++){
                    const cont = createContact(colors[i]);
                    cont.position.set(positions[i][0], positions[i][1], positions[i][2]);
                    cont.userData = { type:'terminal', label:'relay1_'+labels[i], connectedClips:[] };
                    g.add(cont);
                }

                relay1Light = new THREE.Mesh(new THREE.SphereGeometry(0.1,16,16), new THREE.MeshBasicMaterial({ color:0x00ff00 }));
                relay1Light.position.set(0,0.6,0);
                relay1Light.visible = false;
                g.add(relay1Light);

                g.position.set(-1.5,0.4,-1);
                g.userData = { movable:true, type:'movable', label:'relay1' };
                scene.add(g);
                relay1 = g;
            }

            function createRelay2() { // –Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–æ–µ (—Å –∫—Ä–∞—Å–Ω—ã–º –æ—Ç—Ç–µ–Ω–∫–æ–º)
                const g = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.5,0.8,1.5), new THREE.MeshPhongMaterial({ color:0x884444, shininess:70 }));
                body.castShadow = true;
                body.userData.isBody = true;
                g.add(body);

                // –ú–∞—Ä–∫–∏—Ä–æ–≤–∫–∞ "2" –∏ –∫—Ä–∞—Å–Ω–∞—è –ø–æ–ª–æ—Å–∞
                const markerMat = new THREE.MeshPhongMaterial({ color:0xff0000 });
                const marker = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.1,0.1), markerMat);
                marker.position.set(0,0.5,0.8);
                g.add(marker);

                const labels = ['85','86','87','30'];
                const colors = [0x3366ff,0xff3333,0xff3333,0xff3333];
                const positions = [[-0.5,0.4,-0.5],[0.5,0.4,-0.5],[0.5,0.4,0.5],[-0.5,0.4,0.5]];
                for(let i=0;i<4;i++){
                    const cont = createContact(colors[i]);
                    cont.position.set(positions[i][0], positions[i][1], positions[i][2]);
                    cont.userData = { type:'terminal', label:'relay2_'+labels[i], connectedClips:[] };
                    g.add(cont);
                }

                relay2Light = new THREE.Mesh(new THREE.SphereGeometry(0.1,16,16), new THREE.MeshBasicMaterial({ color:0xff0000 }));
                relay2Light.position.set(0,0.6,0);
                relay2Light.visible = false; // –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –∑–∞–≥–æ—Ä–∏—Ç—Å—è, –Ω–æ –æ—Å—Ç–∞–≤–∏–º –¥–ª—è –≤–∏–¥–∞
                g.add(relay2Light);

                g.position.set(1.5,0.4,-1);
                g.userData = { movable:true, type:'movable', label:'relay2' };
                scene.add(g);
                relay2 = g;
            }

            function createLamp() {
                const g = new THREE.Group();

                const base = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,0.5,32), new THREE.MeshPhongMaterial({ color:0x888888, shininess:100 }));
                base.castShadow = true;
                base.receiveShadow = true;
                base.userData.isBody = true;
                g.add(base);

                const bulbMat = new THREE.MeshPhongMaterial({ color:0xffdd88, emissive:0x442200, transparent:true, opacity:0.85, shininess:30 });
                const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), bulbMat);
                bulb.position.y = 0.7;
                bulb.castShadow = true;
                bulb.receiveShadow = true;
                bulb.userData.isBody = true;
                g.add(bulb);

                const posCont = createContact(0xff3333);
                posCont.position.set(0.4,-0.2,0);
                posCont.userData = { type:'terminal', label:'lamp_plus', connectedClips:[] };
                g.add(posCont);

                const negCont = createContact(0x3366ff);
                negCont.position.set(-0.4,-0.2,0);
                negCont.userData = { type:'terminal', label:'lamp_minus', connectedClips:[] };
                g.add(negCont);

                lampLight = new THREE.PointLight(0xffaa44, 0, 100);
                lampLight.position.set(0,0.7,0);
                g.add(lampLight);

                g.position.set(4,0.7,-1);
                g.userData = { movable:true, type:'movable', label:'lamp' };
                scene.add(g);
                lamp = g;
            }

            function createTerminal(color) {
                const m = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,0.2,16), new THREE.MeshPhongMaterial({ color, shininess:100 }));
                m.rotation.x = Math.PI/2;
                m.castShadow = true;
                return m;
            }

            function createContact(color) {
                const m = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.1,16), new THREE.MeshPhongMaterial({ color, shininess:100 }));
                m.castShadow = true;
                return m;
            }

            function createClipsAndWires() {
                const colors = [0xff3333, 0xff3333, 0x3366ff, 0x3366ff, 0xff3333];
                for (let i=0; i<5; i++) {
                    const start = new Clip(colors[i], i, 'start');
                    const end = new Clip(colors[i], i, 'end');
                    const wire = new Wire(start, end, colors[i]);
                    clips.push(start, end);
                    wires.push(wire);
                }
            }

            function createText(str, size, color) {
                if (!font) return new THREE.Group();
                const geom = new THREE.TextGeometry(str, { font, size, height:0.05, curveSegments:12, bevelEnabled:false });
                geom.computeBoundingBox();
                const w = geom.boundingBox.max.x - geom.boundingBox.min.x;
                const mat = new THREE.MeshBasicMaterial({ color });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.x = -w/2;
                return mesh;
            }

            function addTextLabels() {
                if (battery) {
                    const plus = createText('+', 0.2, 0xffffff);
                    plus.position.set(1.2, 0.9, 0);
                    battery.add(plus);
                    const minus = createText('-', 0.2, 0xffffff);
                    minus.position.set(-1.2, 0.9, 0);
                    battery.add(minus);
                }
                if (relay1) {
                    const labels = ['85','86','87','30'];
                    const pos = [[-0.7,0.6,-0.7],[0.7,0.6,-0.7],[0.7,0.6,0.7],[-0.7,0.6,0.7]];
                    for(let i=0;i<4;i++){
                        const t = createText(labels[i], 0.15, 0xffffff);
                        t.position.set(pos[i][0], pos[i][1], pos[i][2]);
                        t.rotation.x = -0.2;
                        relay1.add(t);
                    }
                }
                if (relay2) {
                    const labels = ['85','86','87','30'];
                    const pos = [[-0.7,0.6,-0.7],[0.7,0.6,-0.7],[0.7,0.6,0.7],[-0.7,0.6,0.7]];
                    for(let i=0;i<4;i++){
                        const t = createText(labels[i], 0.15, 0xffffff);
                        t.position.set(pos[i][0], pos[i][1], pos[i][2]);
                        t.rotation.x = -0.2;
                        relay2.add(t);
                    }
                }
                if (lamp) {
                    const plus = createText('+', 0.15, 0x000000);
                    plus.position.set(0.4, -0.3, 0);
                    lamp.add(plus);
                    const minus = createText('-', 0.15, 0x000000);
                    minus.position.set(-0.4, -0.3, 0);
                    lamp.add(minus);
                }
            }

            // --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π (—Ç–µ –∂–µ, —á—Ç–æ –∏ —Ä–∞–Ω–µ–µ) ---
            function onPointerDown(e) {
                e.preventDefault();
                if (e.button !== 0) return;

                mouse.x = (e.clientX/window.innerWidth)*2-1;
                mouse.y = -(e.clientY/window.innerHeight)*2+1;
                raycaster.setFromCamera(mouse, camera);
                scene.updateMatrixWorld(true);

                const clipParts = [];
                scene.traverse(obj => { if (obj.userData?.isClipPart) clipParts.push(obj); });
                const clipIntersects = raycaster.intersectObjects(clipParts, true);
                if (clipIntersects.length) {
                    let obj = clipIntersects[0].object;
                    while (obj && !obj.userData.clipObject) obj = obj.parent;
                    if (obj?.userData.clipObject) {
                        activeClip = obj.userData.clipObject;
                        isMouseDown = true;
                        isInteracting = true;
                        activeClip.highlight();
                        const camDir = new THREE.Vector3();
                        camera.getWorldDirection(camDir);
                        dragPlane.setFromNormalAndCoplanarPoint(camDir, activeClip.group.position);
                        if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                            dragOffset.copy(activeClip.group.position).sub(intersectPoint);
                        }
                        if (hoveredClip) { hoveredClip.unhighlight(); hoveredClip = null; }
                        controls.enabled = false;
                        return;
                    }
                }

                const movables = [];
                scene.traverse(obj => { if (obj.userData?.movable) movables.push(obj); });
                const movableIntersects = raycaster.intersectObjects(movables, true);
                if (movableIntersects.length) {
                    let obj = movableIntersects[0].object;
                    while (obj && !obj.userData.movable) obj = obj.parent;
                    if (obj && obj.userData.movable) {
                        const hitObj = movableIntersects[0].object;
                        if (hitObj.userData.isBody || hitObj.parent?.userData?.movable) {
                            activeMovable = obj;
                            isMouseDown = true;
                            isInteracting = true;
                            isDraggingMovable = true;
                            originalMovablePos.copy(obj.position);
                            highlightMovable(obj);
                            dragPlane.setFromNormalAndCoplanarPoint(new THREE.Vector3(0,1,0), obj.position);
                            if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                                dragOffset.copy(obj.position).sub(intersectPoint);
                            }
                            controls.enabled = false;
                        }
                    }
                }
            }

            function onPointerMove(e) {
                if (isInteracting) e.preventDefault();

                mouse.x = (e.clientX/window.innerWidth)*2-1;
                mouse.y = -(e.clientY/window.innerHeight)*2+1;
                raycaster.setFromCamera(mouse, camera);

                if (isMouseDown && isInteracting && activeClip) {
                    isDragging = true;
                    if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                        activeClip.group.position.copy(intersectPoint.add(dragOffset));
                        if (activeClip.wire) activeClip.wire.updateGeometry();
                    }
                    checkTerminalHover();
                    return;
                }

                if (isMouseDown && isInteracting && activeMovable) {
                    if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                        const newPos = intersectPoint.add(dragOffset);
                        newPos.y = originalMovablePos.y;
                        activeMovable.position.copy(newPos);
                        updateAttachedClips(activeMovable);
                        updateWiresForComponent(activeMovable);
                    }
                    return;
                }

                checkClipHover();
                if (!hoveredClip) checkMovableHover();
                else if (hoveredMovable) { unhighlightMovable(hoveredMovable); hoveredMovable = null; }
            }

            function onPointerUp(e) {
                if (e.button !== 0) return;
                if (isInteracting && activeClip) {
                    tryConnectWire();
                } else if (activeMovable) {
                    isDraggingMovable = false;
                    unhighlightMovable(activeMovable);
                    activeMovable = null;
                    checkCircuit();
                }
                isMouseDown = false;
                isDragging = false;
                isInteracting = false;
                if (activeClip) { activeClip.unhighlight(); activeClip = null; }
                controls.enabled = true;
            }

            function checkClipHover() {
                const clipParts = [];
                scene.traverse(obj => { if (obj.userData?.isClipPart) clipParts.push(obj); });
                scene.updateMatrixWorld(true);
                const intersects = raycaster.intersectObjects(clipParts, true);

                if (hoveredClip) {
                    hoveredClip.unhighlight();
                    hoveredClip = null;
                    renderer.domElement.style.cursor = 'auto';
                    isOverClip = false;
                }

                if (intersects.length && !isInteracting) {
                    let obj = intersects[0].object;
                    while (obj && !obj.userData.clipObject) obj = obj.parent;
                    if (obj?.userData.clipObject) {
                        hoveredClip = obj.userData.clipObject;
                        hoveredClip.highlight();
                        renderer.domElement.style.cursor = 'pointer';
                        isOverClip = true;
                    }
                }
            }

            function checkMovableHover() {
                const movables = [];
                scene.traverse(obj => { if (obj.userData?.movable) movables.push(obj); });
                const intersects = raycaster.intersectObjects(movables, true);
                
                if (hoveredMovable) {
                    unhighlightMovable(hoveredMovable);
                    hoveredMovable = null;
                    renderer.domElement.style.cursor = 'auto';
                }

                if (intersects.length && !isInteracting) {
                    const hitObj = intersects[0].object;
                    if (hitObj.userData.isBody || hitObj.parent?.userData?.movable) {
                        let obj = hitObj;
                        while (obj && !obj.userData.movable) obj = obj.parent;
                        if (obj) {
                            hoveredMovable = obj;
                            highlightMovable(obj);
                            renderer.domElement.style.cursor = 'move';
                        }
                    }
                }
            }

            function highlightMovable(obj) {
                obj.traverse(c => {
                    if (c.userData.isBody && c.material && c.material.emissive !== undefined) {
                        if (!originalMaterials.has(c)) originalMaterials.set(c, c.material);
                        if (Array.isArray(c.material)) {
                            c.material.forEach(m => { if (m.emissive) m.emissive = new THREE.Color(0x333333); });
                        } else {
                            c.material.emissive = new THREE.Color(0x333333);
                        }
                    }
                });
            }

            function unhighlightMovable(obj) {
                obj.traverse(c => {
                    if (c.userData.isBody && c.material && originalMaterials.has(c)) {
                        if (Array.isArray(c.material)) {
                            c.material.forEach(m => { if (m.emissive) m.emissive = new THREE.Color(0x000000); });
                        } else {
                            c.material.emissive = new THREE.Color(0x000000);
                        }
                    }
                });
            }

            function updateAttachedClips(comp) {
                const terms = [];
                comp.traverse(c => { if (c.userData?.type === 'terminal') terms.push(c); });
                terms.forEach(term => {
                    (term.userData.connectedClips || []).forEach(clip => {
                        const wp = new THREE.Vector3();
                        term.getWorldPosition(wp);
                        clip.group.position.copy(wp);
                        clip.group.position.y += 0.15;
                    });
                });
            }

            function updateWiresForComponent(comp) {
                const terms = [];
                comp.traverse(c => { if (c.userData?.type === 'terminal') terms.push(c); });
                const affected = new Set();
                terms.forEach(term => {
                    (term.userData.connectedClips || []).forEach(clip => { if (clip.wire) affected.add(clip.wire); });
                });
                affected.forEach(w => w.updateGeometry());
            }

            function checkTerminalHover() {
                const terms = [];
                scene.traverse(obj => { if (obj.userData?.type === 'terminal') terms.push(obj); });
                scene.updateMatrixWorld(true);
                const intersects = raycaster.intersectObjects(terms, true);

                if (hoveredTerminal) {
                    resetObjectHighlight(hoveredTerminal);
                    hoveredTerminal = null;
                }

                if (intersects.length) {
                    const obj = intersects[0].object;
                    if (activeClip && obj.material.color.getHex() === activeClip.color) {
                        hoveredTerminal = obj;
                        setObjectHighlight(obj);
                        renderer.domElement.style.cursor = 'pointer';
                    } else {
                        renderer.domElement.style.cursor = 'not-allowed';
                    }
                } else {
                    renderer.domElement.style.cursor = 'move';
                }
            }

            function setObjectHighlight(obj) {
                if (!originalMaterials.has(obj)) originalMaterials.set(obj, obj.material);
                obj.material.emissive = new THREE.Color(0x333333);
            }
            function resetObjectHighlight(obj) {
                if (originalMaterials.has(obj)) obj.material.emissive = new THREE.Color(0x000000);
            }

            function tryConnectWire() {
                if (hoveredTerminal && activeClip) {
                    const isOccupied = !hoveredTerminal.userData.label.startsWith('battery_') && hoveredTerminal.userData.connectedClips.length > 0;
                    if (isOccupied) {
                        activeClip.group.position.copy(activeClip.homePos);
                        if (activeClip.wire) activeClip.wire.updateGeometry();
                        if (activeClip.connectedTerminal) {
                            const old = activeClip.connectedTerminal;
                            const idx = old.userData.connectedClips.indexOf(activeClip);
                            if (idx !== -1) old.userData.connectedClips.splice(idx,1);
                            activeClip.connectedTerminal = null;
                            activeClip.connected = false;
                        }
                    } else {
                        if (activeClip.connectedTerminal) {
                            const old = activeClip.connectedTerminal;
                            const idx = old.userData.connectedClips.indexOf(activeClip);
                            if (idx !== -1) old.userData.connectedClips.splice(idx,1);
                        }
                        activeClip.connectToTerminal(hoveredTerminal);
                        hoveredTerminal.userData.connectedClips.push(activeClip);
                    }
                } else {
                    activeClip.group.position.copy(activeClip.homePos);
                    if (activeClip.wire) activeClip.wire.updateGeometry();
                    if (activeClip.connectedTerminal) {
                        const old = activeClip.connectedTerminal;
                        const idx = old.userData.connectedClips.indexOf(activeClip);
                        if (idx !== -1) old.userData.connectedClips.splice(idx,1);
                        activeClip.connectedTerminal = null;
                        activeClip.connected = false;
                    }
                }
                resetDragState();
            }

            function resetDragState() {
                if (hoveredTerminal) { resetObjectHighlight(hoveredTerminal); hoveredTerminal = null; }
                isDragging = false;
                renderer.domElement.style.cursor = isOverClip ? 'pointer' : 'auto';
                checkCircuit();
            }

            // --- –õ–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ü–µ–ø–∏ —Å –¥–≤—É–º—è —Ä–µ–ª–µ ---
            function checkCircuit() {
                document.getElementById('lamp-status').textContent = '–í—ã–∫–ª';
                document.getElementById('lamp-status').className = 'status-value off';
                document.getElementById('relay1-status').textContent = '–ù–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ';
                document.getElementById('relay2-status').textContent = '–ù–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ';
                lampLight.intensity = 0;
                if (relay1Light) relay1Light.visible = false;
                if (relay2Light) relay2Light.visible = false;

                const terms = {};
                scene.traverse(obj => { if (obj.userData?.type === 'terminal' && obj.userData.label) terms[obj.userData.label] = obj; });

                const batP = terms['battery_plus'];
                const batM = terms['battery_minus'];
                const lampP = terms['lamp_plus'];
                const lampM = terms['lamp_minus'];

                // –†–µ–ª–µ 1
                const r1_85 = terms['relay1_85'];
                const r1_86 = terms['relay1_86'];
                const r1_87 = terms['relay1_87'];
                const r1_30 = terms['relay1_30'];

                // –†–µ–ª–µ 2
                const r2_85 = terms['relay2_85'];
                const r2_86 = terms['relay2_86'];
                const r2_87 = terms['relay2_87'];
                const r2_30 = terms['relay2_30'];

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä—è–º–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ (–º–∏–Ω—É—è —Ä–µ–ª–µ)
                if (checkConnection(batP, lampP) && checkConnection(batM, lampM)) {
                    document.getElementById('connection-status').innerHTML = '–ü—Ä—è–º–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ (–º–∏–Ω—É—è —Ä–µ–ª–µ)';
                    document.getElementById('connection-status').className = 'on';
                    document.getElementById('lamp-status').textContent = '–í–∫–ª';
                    document.getElementById('lamp-status').className = 'status-value on';
                    lampLight.intensity = 1;
                    return;
                }

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–∞—Ü–∏—é —Ä–µ–ª–µ 1
                const relay1Energized = (checkConnection(batP, r1_86) && checkConnection(batM, r1_85)) || 
                                         (checkConnection(batP, r1_85) && checkConnection(batM, r1_86));
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ –ª–∏ –ª–∞–º–ø–∞ —á–µ—Ä–µ–∑ —Ä–µ–ª–µ 1: + –±–∞—Ç–∞—Ä–µ–∏ –Ω–∞ 30, –ª–∞–º–ø–∞ –º–µ–∂–¥—É 87 –∏ –º–∏–Ω—É—Å–æ–º
                const lampViaRelay1 = checkConnection(batP, r1_30) && checkConnection(r1_87, lampP) && checkConnection(batM, lampM);

                if (relay1Energized) {
                    document.getElementById('relay1-status').textContent = '–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ';
                    if (!RELAY1_FAULTY) {
                        relay1Light.visible = true;
                    }
                }

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–∞—Ü–∏—é —Ä–µ–ª–µ 2
                const relay2Energized = (checkConnection(batP, r2_86) && checkConnection(batM, r2_85)) || 
                                         (checkConnection(batP, r2_85) && checkConnection(batM, r2_86));
                const lampViaRelay2 = checkConnection(batP, r2_30) && checkConnection(r2_87, lampP) && checkConnection(batM, lampM);

                if (relay2Energized) {
                    document.getElementById('relay2-status').textContent = '–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ (–Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–æ)';
                    // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–µ –∑–∞–∂–∏–≥–∞–µ–º, —Ç–∞–∫ –∫–∞–∫ —Ä–µ–ª–µ –Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–æ
                }

                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –≥–æ—Ä–∏—Ç –ª–∏ –ª–∞–º–ø–∞
                let lampOn = false;
                let circuitDesc = '';

                if (lampViaRelay1 && relay1Energized) {
                    if (!RELAY1_FAULTY) {
                        lampOn = true;
                        circuitDesc = '–ß–µ—Ä–µ–∑ –∏—Å–ø—Ä–∞–≤–Ω–æ–µ —Ä–µ–ª–µ 1';
                    } else {
                        circuitDesc = '–†–µ–ª–µ 1 –Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–æ (–Ω–µ –∑–∞–º—ã–∫–∞–µ—Ç)';
                    }
                } else if (lampViaRelay2 && relay2Energized) {
                    if (!RELAY2_FAULTY) {
                        lampOn = true;
                        circuitDesc = '–ß–µ—Ä–µ–∑ —Ä–µ–ª–µ 2 (–∏—Å–ø—Ä–∞–≤–Ω–æ)';
                    } else {
                        circuitDesc = '–†–µ–ª–µ 2 –Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–æ (–Ω–µ –∑–∞–º—ã–∫–∞–µ—Ç)';
                    }
                } else {
                    circuitDesc = '–¶–µ–ø—å –Ω–µ –∑–∞–º–∫–Ω—É—Ç–∞ –∏–ª–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ';
                }

                if (lampOn) {
                    document.getElementById('lamp-status').textContent = '–í–∫–ª';
                    document.getElementById('lamp-status').className = 'status-value on';
                    lampLight.intensity = 1;
                    document.getElementById('connection-status').innerHTML = circuitDesc + ' ‚úì';
                    document.getElementById('connection-status').className = 'on';
                } else {
                    document.getElementById('lamp-status').textContent = '–í—ã–∫–ª';
                    document.getElementById('lamp-status').className = 'status-value off';
                    lampLight.intensity = 0;
                    document.getElementById('connection-status').innerHTML = circuitDesc;
                    document.getElementById('connection-status').className = relay1Energized || relay2Energized ? 'faulty' : 'off';
                }
            }

            function checkConnection(a, b) {
                if (!a || !b) return false;
                for (let clip of a.userData.connectedClips) {
                    if (clip.wire) {
                        const other = clip.wire.startClip === clip ? clip.wire.endClip : clip.wire.startClip;
                        if (other.connectedTerminal === b) return true;
                    }
                }
                return false;
            }

            function resetConnections() {
                scene.traverse(obj => { if (obj.userData?.type === 'terminal' && obj.userData.connectedClips) obj.userData.connectedClips = []; });
                clips.forEach(c => c.disconnect());
                checkCircuit();
            }

            // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π ---
            function moveCamera(direction) {
                const speed = 0.5;
                const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
                forward.y = 0;
                right.y = 0;
                forward.normalize();
                right.normalize();

                switch(direction) {
                    case 'up': camera.position.y += speed; controls.target.y += speed; break;
                    case 'down': camera.position.y -= speed; controls.target.y -= speed; break;
                    case 'left': camera.position.sub(right.multiplyScalar(speed)); controls.target.sub(right.multiplyScalar(speed)); break;
                    case 'right': camera.position.add(right.multiplyScalar(speed)); controls.target.add(right.multiplyScalar(speed)); break;
                }
                controls.update();
            }

            function zoomCamera(type) {
                const step = 0.5;
                const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                if (type === 'in') {
                    camera.position.sub(dir.multiplyScalar(step));
                } else {
                    camera.position.add(dir.multiplyScalar(step));
                }
                controls.update();
            }

            // --- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ ---
            function showHintModal() {
                const modal = document.getElementById('modal');
                showInstructionScreen();
                modal.style.display = 'block';
            }

            function showInstructionScreen() {
                const content = document.getElementById('modal-content');
                const buttons = document.getElementById('modal-buttons');
                content.innerHTML = `
                    <h3>üìò –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è</h3>
                    <ul>
                        <li>–ö–æ—Å–Ω–∏—Ç–µ—Å—å –∑–∞–∂–∏–º–∞, —á—Ç–æ–±—ã –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –µ–≥–æ</li>
                        <li>–£–¥–µ—Ä–∂–∏–≤–∞—è, –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∫ –Ω—É–∂–Ω–æ–π –∫–ª–µ–º–º–µ</li>
                        <li>–û—Ç–ø—É—Å—Ç–∏—Ç–µ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è</li>
                        <li>–ö –∫–ª–µ–º–º–∞–º –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä–∞ –º–æ–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–∞–∂–∏–º–æ–≤</li>
                        <li>–ö–æ—Å–Ω–∏—Ç–µ—Å—å –∫–æ—Ä–ø—É—Å–∞ —Ä–µ–ª–µ, –ª–∞–º–ø—ã –∏–ª–∏ –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä–∞ –∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ, —á—Ç–æ–±—ã –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å</li>
                        <li><strong>–†–µ–ª–µ 1 (—Å–µ—Ä–æ–µ) ‚Äî –∏—Å–ø—Ä–∞–≤–Ω–æ</strong></li>
                        <li><strong>–†–µ–ª–µ 2 (–∫—Ä–∞—Å–Ω–æ–≤–∞—Ç–æ–µ) ‚Äî –Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–æ (–Ω–µ –∑–∞–º—ã–∫–∞–µ—Ç –∫–æ–Ω—Ç–∞–∫—Ç—ã)</strong></li>
                    </ul>
                `;
                buttons.innerHTML = `
                    <button class="secondary" id="modal-schema-btn">üîå –°—Ö–µ–º–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è</button>
                    <button id="modal-start-btn">‚ñ∂ –ù–∞—á–∞—Ç—å</button>
                `;
                document.getElementById('modal-schema-btn').addEventListener('click', showSchemaScreen);
                document.getElementById('modal-start-btn').addEventListener('click', () => {
                    document.getElementById('modal').style.display = 'none';
                });
            }

            function showSchemaScreen() {
                const content = document.getElementById('modal-content');
                const buttons = document.getElementById('modal-buttons');
                content.innerHTML = `
                    <h3>üîå –°—Ö–µ–º–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —Ä–µ–ª–µ</h3>
                    <p style="text-align:left;">
                        <strong>–ö–æ–Ω—Ç–∞–∫—Ç—ã —Ä–µ–ª–µ:</strong><br>
                        ‚Ä¢ <span style="color:#ff6666;">86</span> –∏ <span style="color:#6666ff;">85</span> ‚Äî –ø–∏—Ç–∞–Ω–∏–µ –∫–∞—Ç—É—à–∫–∏ (–ø–æ–ª—è—Ä–Ω–æ—Å—Ç—å –Ω–µ –≤–∞–∂–Ω–∞, –Ω–æ –æ–±—ã—á–Ω–æ 86 –Ω–∞ +, 85 –Ω–∞ -)<br>
                        ‚Ä¢ <span style="color:#ff6666;">30</span> ‚Äî –æ–±—â–∏–π –∫–æ–Ω—Ç–∞–∫—Ç (–ø–∏—Ç–∞–Ω–∏–µ –æ—Ç –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä–∞)<br>
                        ‚Ä¢ <span style="color:#ff6666;">87</span> ‚Äî –Ω–æ—Ä–º–∞–ª—å–Ω–æ —Ä–∞–∑–æ–º–∫–Ω—É—Ç—ã–π (–ø–∏—Ç–∞–Ω–∏–µ –Ω–∞–≥—Ä—É–∑–∫–∏, –∫–æ–≥–¥–∞ —Ä–µ–ª–µ –≤–∫–ª—é—á–µ–Ω–æ)<br><br>
                        <strong>–ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏:</strong><br>
                        1. –ü–∏—Ç–∞–Ω–∏–µ –∫–∞—Ç—É—à–∫–∏: + –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä–∞ –Ω–∞ 86, - –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä–∞ –Ω–∞ 85<br>
                        2. –ü–∏—Ç–∞–Ω–∏–µ –Ω–∞–≥—Ä—É–∑–∫–∏: + –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä–∞ –Ω–∞ 30, –ª–∞–º–ø–∞ –º–µ–∂–¥—É 87 –∏ –º–∏–Ω—É—Å–æ–º<br>
                        3. –ü—Ä–∏ –ø–æ–¥–∞—á–µ –ø–∏—Ç–∞–Ω–∏—è –Ω–∞ –∫–∞—Ç—É—à–∫—É –∏—Å–ø—Ä–∞–≤–Ω–æ–≥–æ —Ä–µ–ª–µ –ª–∞–º–ø–∞ –∑–∞–≥–æ—Ä–∞–µ—Ç—Å—è<br>
                        <strong style="color:#ff6666;">–ù–µ–∏—Å–ø—Ä–∞–≤–Ω–æ–µ —Ä–µ–ª–µ (‚Ññ2) –Ω–µ –≤–∫–ª—é—á–∏—Ç –ª–∞–º–ø—É –¥–∞–∂–µ –ø—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏.</strong>
                    </p>
                `;
                buttons.innerHTML = `
                    <button class="back" id="modal-back-btn">‚óÄ –ù–∞–∑–∞–¥</button>
                    <button class="secondary" id="modal-start-btn2">‚ñ∂ –ù–∞—á–∞—Ç—å</button>
                `;
                document.getElementById('modal-back-btn').addEventListener('click', showInstructionScreen);
                document.getElementById('modal-start-btn2').addEventListener('click', () => {
                    document.getElementById('modal').style.display = 'none';
                });
            }

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            window.addEventListener('load', init);
            window.addEventListener('resize', ()=>{
                if (camera && renderer) {
                    camera.aspect = window.innerWidth/window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
        })();
    </script>
</body>
</html>
