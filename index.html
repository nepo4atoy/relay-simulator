<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D симулятор проверки автомобильного реле (моб.)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <style>
        body { margin:0; overflow:hidden; font-family:Arial,sans-serif; background:linear-gradient(135deg,#2c3e50,#1a1a2e); }
        canvas {
            display:block;
            outline:none;
            touch-action: none; /* отключаем прокрутку/масштабирование браузера на canvas */
        }
        /* Общие стили панелей */
        #info-panel, #instructions {
            position:absolute;
            background:rgba(0,0,0,0.8);
            color:#fff;
            padding:15px;
            border-radius:8px;
            z-index:100;
            box-shadow:0 4px 12px rgba(0,0,0,0.5);
            border:1px solid #444;
            pointer-events: none; /* чтобы не мешать касаниям сквозь панель */
        }
        #info-panel { top:10px; left:10px; max-width:300px; }
        #instructions { bottom:10px; left:10px; max-width:300px; }
        /* Кнопки внутри панелей должны получать события */
        #info-panel button, #instructions button {
            pointer-events: auto;
            background:#3498db;
            color:#fff;
            border:none;
            padding:12px 20px;
            border-radius:6px;
            cursor:pointer;
            margin:5px 2px;
            font-weight:bold;
            transition:background 0.3s;
            width: calc(100% - 10px);
            font-size: 16px;
        }
        #info-panel button:hover, #instructions button:hover {
            background:#2980b9;
        }
        #reset-btn { background:#e74c3c; }
        #reset-btn:hover { background:#c0392b; }
        #hint-btn { background:#9b59b6; }
        #hint-btn:hover { background:#8e44ad; }
        .status {
            margin-top:10px;
            padding:8px;
            border-radius:5px;
            text-align:center;
            font-weight:bold;
        }
        .on { background:#2ecc71; }
        .off { background:#e74c3c; }
        #hint {
            position:absolute;
            top:50%;
            left:50%;
            transform:translate(-50%,-50%);
            background:rgba(255,255,255,0.95);
            padding:30px;
            border-radius:15px;
            text-align:center;
            box-shadow:0 0 30px rgba(0,0,0,0.7);
            z-index:1000;
            width:80%;
            max-width:500px;
            pointer-events: auto;
        }
        #start-btn {
            background:#27ae60;
            padding:15px 30px;
            font-size:18px;
            width:auto;
            margin-top:20px;
        }
        #drag-hint, #drag-info {
            position:absolute;
            right:20px;
            background:rgba(255,204,0,0.9);
            padding:15px;
            border-radius:6px;
            color:#333;
            font-weight:bold;
            z-index:200;
            font-size:16px;
            max-width:250px;
            text-align:center;
            pointer-events: none;
        }
        #drag-hint { top:20px; }
        #drag-info { top:80px; }
        .terminal-info { margin-top:10px; font-size:13px; color:#ddd; }
        .circuit-diagram { margin-top:15px; border-top:1px solid #555; padding-top:10px; }

        /* Мобильная адаптация */
        @media (max-width: 768px) {
            #info-panel {
                max-width: 220px;
                font-size: 14px;
                padding: 10px;
                top: 5px;
                left: 5px;
            }
            #instructions {
                max-width: 220px;
                font-size: 14px;
                padding: 10px;
                bottom: 5px;
                left: 5px;
            }
            #info-panel button, #instructions button {
                padding: 14px 10px;
                font-size: 16px;
                margin: 4px 0;
            }
            #hint {
                width: 90%;
                padding: 20px;
                font-size: 16px;
            }
            #hint p {
                margin: 12px 0;
            }
            #drag-hint, #drag-info {
                font-size: 16px;
                padding: 12px;
                right: 10px;
            }
            #drag-info { top: 90px; }
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h3>Проверка автомобильного реле</h3>
        <div>Состояние лампы: <span id="lamp-status">Выкл</span></div>
        <div>Реле: <span id="relay-status">Не активировано</span></div>
        <div class="status off" id="connection-status">Цепь не замкнута</div>
        <div class="terminal-info">Клеммы аккумулятора поддерживают несколько подключений</div>
        <div class="circuit-diagram"><strong>Схема подключения:</strong><div id="circuit-image"></div></div>
    </div>
    <div id="instructions">
        <h3>Инструкция (сенсорная)</h3>
        <p>1. Коснитесь зажима, чтобы захватить его</p>
        <p>2. Удерживая, перетащите к нужной клемме</p>
        <p>3. Отпустите для подключения</p>
        <p>4. К клеммам аккумулятора можно подключить несколько зажимов</p>
        <p><strong>Новое:</strong> Коснитесь корпуса реле, лампы или аккумулятора и перетащите, чтобы переместить</p>
        <button id="reset-btn">Сбросить подключения</button>
        <button id="hint-btn">Показать подсказку</button>
    </div>
    <div id="hint">
        <h2>3D симулятор проверки реле</h2>
        <p>Коснитесь зажима, чтобы захватить его</p>
        <p>Удерживайте и перетащите к нужной клемме</p>
        <p>Отпустите для подключения</p>
        <p>К клеммам аккумулятора можно подключить несколько зажимов</p>
        <p><strong>Новое:</strong> Коснитесь корпуса реле, лампы или аккумулятора и перетащите, чтобы переместить их</p>
        <button id="start-btn">Начать</button>
    </div>
    <div id="drag-hint">Коснитесь и удерживайте для захвата провода</div>
    <div id="drag-info">Перетащите к клемме и отпустите</div>

    <script>
        (function() {
            // --- Переменные ---
            let scene, camera, renderer, controls;
            let relay, battery, lamp;
            let clips = [];
            let wires = [];
            let activeClip = null;
            let activeMovable = null;
            let lampLight, relayLight;
            let raycaster, mouse;
            let isDragging = false;
            let isDraggingMovable = false;
            let dragPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 1);
            let dragOffset = new THREE.Vector3();
            let intersectPoint = new THREE.Vector3();
            let hoveredClip = null;
            let hoveredMovable = null;
            let hoveredTerminal = null;
            let originalMaterials = new WeakMap();
            let originalMovablePos = new THREE.Vector3();
            let isMouseDown = false;
            let isOverClip = false;
            let isInteracting = false;
            let font = null;

            // --- Класс Зажим ---
            class Clip {
                constructor(color, index, endType) {
                    this.group = new THREE.Group();
                    this.index = index;
                    this.endType = endType;
                    this.color = color;
                    this.connected = false;
                    this.connectedTerminal = null;
                    this.wire = null;

                    const mat = new THREE.MeshPhongMaterial({ color, shininess:100 });
                    const base = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.1,0.4), mat);
                    base.userData.isClipPart = true;
                    this.group.add(base);

                    for (let i=0; i<3; i++) {
                        const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.4), mat);
                        tooth.position.set(-0.1+i*0.1, -0.1, 0);
                        tooth.userData.isClipPart = true;
                        this.group.add(tooth);
                    }
                    const handle = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.1,0.2), mat);
                    handle.position.set(0.3, 0.1, 0);
                    handle.userData.isClipPart = true;
                    this.group.add(handle);

                    // Начальная позиция на столе (НЕИЗМЕННАЯ)
                    if (index === 0) {
                        if (endType === 'start') this.group.position.set(-3.5,1,-2);
                        else { this.group.position.set(-2.5,1,-2); this.group.rotation.y = Math.PI; }
                    } else {
                        this.group.position.set(-4 + index*1.5, 1, -2);
                    }

                    this.group.userData = { type:'clip', clipObject:this };
                    this.homePos = this.group.position.clone();
                    scene.add(this.group);
                }
                setWire(w) { this.wire = w; }
                connectToTerminal(term) {
                    this.connected = true;
                    this.connectedTerminal = term;
                    const wp = new THREE.Vector3();
                    term.getWorldPosition(wp);
                    this.group.position.copy(wp);
                    this.group.position.y += 0.15;
                    if (this.wire) this.wire.updateGeometry();
                }
                disconnect() {
                    this.connected = false;
                    this.connectedTerminal = null;
                    this.group.position.copy(this.homePos);
                    if (this.wire) this.wire.updateGeometry();
                }
                highlight() { this.group.traverse(c => { if(c.isMesh) c.material.emissive = new THREE.Color(0x555555); }); }
                unhighlight() { this.group.traverse(c => { if(c.isMesh) c.material.emissive = new THREE.Color(0x000000); }); }
            }

            // --- Класс Провод (увеличенного диаметра) ---
            class Wire {
                constructor(startClip, endClip, color) {
                    this.startClip = startClip;
                    this.endClip = endClip;
                    this.color = color;

                    const geom = new THREE.CylinderGeometry(0.08, 0.08, 1, 8);
                    const mat = new THREE.MeshPhongMaterial({ color, emissive:0x222222 });
                    this.mesh = new THREE.Mesh(geom, mat);
                    this.mesh.userData.type = 'wire';
                    this.mesh.castShadow = true;
                    this.mesh.receiveShadow = true;

                    startClip.setWire(this);
                    endClip.setWire(this);

                    this.updateGeometry();
                    scene.add(this.mesh);
                }
                updateGeometry() {
                    if (!this.mesh) return;
                    this.startClip.group.updateMatrixWorld(true);
                    this.endClip.group.updateMatrixWorld(true);
                    
                    const startPos = new THREE.Vector3();
                    const endPos = new THREE.Vector3();
                    this.startClip.group.getWorldPosition(startPos);
                    this.endClip.group.getWorldPosition(endPos);

                    const dist = startPos.distanceTo(endPos);
                    if (dist < 0.01) {
                        this.mesh.scale.y = 0.01;
                        this.mesh.position.copy(startPos);
                        return;
                    }
                    const center = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);

                    this.mesh.position.copy(center);
                    this.mesh.lookAt(endPos);
                    this.mesh.rotateX(Math.PI/2);
                    this.mesh.scale.y = dist;
                }
            }

            // --- Инициализация сцены ---
            function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a2e);
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.set(0,5,10);
                renderer = new THREE.WebGLRenderer({ antialias:true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
                // отключаем встроенный touch, чтобы наш обработчик работал без конфликтов
                controls.enableTouch = false; // мы сами обрабатываем touch через pointer events

                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                const ambient = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambient);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(10,20,15);
                dirLight.castShadow = true;
                scene.add(dirLight);

                const table = new THREE.Mesh(
                    new THREE.BoxGeometry(20,0.5,20),
                    new THREE.MeshPhongMaterial({ color:0x8B4513, shininess:30 })
                );
                table.position.y = -0.25;
                table.receiveShadow = true;
                scene.add(table);

                // Компоненты
                createBattery();
                createRelay();
                createLamp();
                createClipsAndWires();

                const loader = new THREE.FontLoader();
                loader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json',
                    f => { font = f; addTextLabels(); },
                    undefined,
                    e => console.warn('Шрифт не загружен, текст не отображается', e)
                );

                const grid = new THREE.GridHelper(20,20,0x555555,0x333333);
                scene.add(grid);

                renderer.domElement.addEventListener('pointerdown', onPointerDown);
                renderer.domElement.addEventListener('pointermove', onPointerMove);
                renderer.domElement.addEventListener('pointerup', onPointerUp);
                renderer.domElement.addEventListener('pointercancel', onPointerUp); // на случай прерывания
                renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

                document.getElementById('reset-btn').addEventListener('click', resetConnections);
                document.getElementById('hint-btn').addEventListener('click', ()=>document.getElementById('hint').style.display='block');
                document.getElementById('start-btn').addEventListener('click', ()=>document.getElementById('hint').style.display='none');

                animate();
            }

            function createBattery() {
                const g = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(2,1,1), new THREE.MeshPhongMaterial({ color:0x222222, shininess:50 }));
                body.castShadow = true;
                body.userData.isBody = true;
                g.add(body);

                const posTerm = createTerminal(0xff3333);
                posTerm.position.set(1.2,0.5,0);
                posTerm.userData = { type:'terminal', label:'battery_plus', connectedClips:[] };
                g.add(posTerm);

                const negTerm = createTerminal(0x3366ff);
                negTerm.position.set(-1.2,0.5,0);
                negTerm.userData = { type:'terminal', label:'battery_minus', connectedClips:[] };
                g.add(negTerm);

                g.position.set(-5,0.5,0);
                g.rotation.y = Math.PI/2;
                g.userData = { movable:true, type:'movable', label:'battery' };
                scene.add(g);
                battery = g;
            }

            function createRelay() {
                const g = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.5,0.8,1.5), new THREE.MeshPhongMaterial({ color:0x444444, shininess:70 }));
                body.castShadow = true;
                body.userData.isBody = true;
                g.add(body);

                const labels = ['85','86','87','30'];
                const colors = [0x3366ff,0xff3333,0xff3333,0xff3333];
                const positions = [[-0.5,0.4,-0.5],[0.5,0.4,-0.5],[0.5,0.4,0.5],[-0.5,0.4,0.5]];
                for(let i=0;i<4;i++){
                    const cont = createContact(colors[i]);
                    cont.position.set(positions[i][0], positions[i][1], positions[i][2]);
                    cont.userData = { type:'terminal', label:'relay_'+labels[i], connectedClips:[] };
                    g.add(cont);
                }

                relayLight = new THREE.Mesh(new THREE.SphereGeometry(0.1,16,16), new THREE.MeshBasicMaterial({ color:0xff0000 }));
                relayLight.position.set(0,0.6,0);
                relayLight.visible = false;
                g.add(relayLight);

                g.position.set(0,0.4,0);
                g.userData = { movable:true, type:'movable', label:'relay' };
                scene.add(g);
                relay = g;
            }

            function createLamp() {
                const g = new THREE.Group();

                const base = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,0.5,32), new THREE.MeshPhongMaterial({ color:0x888888, shininess:100 }));
                base.castShadow = true;
                base.receiveShadow = true;
                base.userData.isBody = true;
                g.add(base);

                const bulbMat = new THREE.MeshPhongMaterial({ color:0xffdd88, emissive:0x442200, transparent:true, opacity:0.85, shininess:30 });
                const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), bulbMat);
                bulb.position.y = 0.7;
                bulb.castShadow = true;
                bulb.receiveShadow = true;
                bulb.userData.isBody = true;
                g.add(bulb);

                const posCont = createContact(0xff3333);
                posCont.position.set(0.4,-0.2,0);
                posCont.userData = { type:'terminal', label:'lamp_plus', connectedClips:[] };
                g.add(posCont);

                const negCont = createContact(0x3366ff);
                negCont.position.set(-0.4,-0.2,0);
                negCont.userData = { type:'terminal', label:'lamp_minus', connectedClips:[] };
                g.add(negCont);

                lampLight = new THREE.PointLight(0xffaa44, 0, 100);
                lampLight.position.set(0,0.7,0);
                g.add(lampLight);

                g.position.set(5,0.7,0);
                g.userData = { movable:true, type:'movable', label:'lamp' };
                scene.add(g);
                lamp = g;
            }

            function createTerminal(color) {
                const m = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,0.2,16), new THREE.MeshPhongMaterial({ color, shininess:100 }));
                m.rotation.x = Math.PI/2;
                m.castShadow = true;
                return m;
            }

            function createContact(color) {
                const m = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.1,16), new THREE.MeshPhongMaterial({ color, shininess:100 }));
                m.castShadow = true;
                return m;
            }

            function createClipsAndWires() {
                const colors = [0xff3333, 0xff3333, 0x3366ff, 0x3366ff, 0xff3333];
                for (let i=0; i<5; i++) {
                    const start = new Clip(colors[i], i, 'start');
                    const end = new Clip(colors[i], i, 'end');
                    const wire = new Wire(start, end, colors[i]);
                    clips.push(start, end);
                    wires.push(wire);
                }
            }

            function createText(str, size, color) {
                if (!font) return new THREE.Group();
                const geom = new THREE.TextGeometry(str, { font, size, height:0.05, curveSegments:12, bevelEnabled:false });
                geom.computeBoundingBox();
                const w = geom.boundingBox.max.x - geom.boundingBox.min.x;
                const mat = new THREE.MeshBasicMaterial({ color });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.x = -w/2;
                return mesh;
            }

            function addTextLabels() {
                if (battery) {
                    const plus = createText('+', 0.2, 0xffffff);
                    plus.position.set(1.2, 0.9, 0);
                    battery.add(plus);
                    const minus = createText('-', 0.2, 0xffffff);
                    minus.position.set(-1.2, 0.9, 0);
                    battery.add(minus);
                }
                if (relay) {
                    const labels = ['85','86','87','30'];
                    const pos = [[-0.7,0.6,-0.7],[0.7,0.6,-0.7],[0.7,0.6,0.7],[-0.7,0.6,0.7]];
                    for(let i=0;i<4;i++){
                        const t = createText(labels[i], 0.15, 0xffffff);
                        t.position.set(pos[i][0], pos[i][1], pos[i][2]);
                        t.rotation.x = -0.2;
                        relay.add(t);
                    }
                }
                if (lamp) {
                    const plus = createText('+', 0.15, 0x000000);
                    plus.position.set(0.4, -0.3, 0);
                    lamp.add(plus);
                    const minus = createText('-', 0.15, 0x000000);
                    minus.position.set(-0.4, -0.3, 0);
                    lamp.add(minus);
                }
            }

            // --- Обработчики событий ---
            function onPointerDown(e) {
                // Предотвращаем стандартное поведение (прокрутку, выделение)
                e.preventDefault();
                if (e.button !== 0) return; // только левая кнопка или касание

                mouse.x = (e.clientX/window.innerWidth)*2-1;
                mouse.y = -(e.clientY/window.innerHeight)*2+1;
                raycaster.setFromCamera(mouse, camera);
                scene.updateMatrixWorld(true);

                // Поиск зажимов
                const clipParts = [];
                scene.traverse(obj => { if (obj.userData?.isClipPart) clipParts.push(obj); });
                const clipIntersects = raycaster.intersectObjects(clipParts, true);
                if (clipIntersects.length) {
                    let obj = clipIntersects[0].object;
                    while (obj && !obj.userData.clipObject) obj = obj.parent;
                    if (obj?.userData.clipObject) {
                        activeClip = obj.userData.clipObject;
                        isMouseDown = true;
                        isInteracting = true;
                        activeClip.highlight();
                        document.getElementById('drag-hint').style.display = 'none';
                        document.getElementById('drag-info').style.display = 'block';
                        const camDir = new THREE.Vector3();
                        camera.getWorldDirection(camDir);
                        dragPlane.setFromNormalAndCoplanarPoint(camDir, activeClip.group.position);
                        if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                            dragOffset.copy(activeClip.group.position).sub(intersectPoint);
                        }
                        if (hoveredClip) { hoveredClip.unhighlight(); hoveredClip = null; }
                        controls.enabled = false;
                        return;
                    }
                }

                // Поиск перемещаемых объектов
                const movables = [];
                scene.traverse(obj => { if (obj.userData?.movable) movables.push(obj); });
                const movableIntersects = raycaster.intersectObjects(movables, true);
                if (movableIntersects.length) {
                    let obj = movableIntersects[0].object;
                    while (obj && !obj.userData.movable) obj = obj.parent;
                    if (obj && obj.userData.movable) {
                        const hitObj = movableIntersects[0].object;
                        if (hitObj.userData.isBody || hitObj.parent?.userData?.movable) {
                            activeMovable = obj;
                            isMouseDown = true;
                            isInteracting = true;
                            isDraggingMovable = true;
                            originalMovablePos.copy(obj.position);
                            highlightMovable(obj);
                            dragPlane.setFromNormalAndCoplanarPoint(new THREE.Vector3(0,1,0), obj.position);
                            if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                                dragOffset.copy(obj.position).sub(intersectPoint);
                            }
                            document.getElementById('drag-hint').style.display = 'none';
                            document.getElementById('drag-info').style.display = 'none';
                            controls.enabled = false;
                        }
                    }
                }
            }

            function onPointerMove(e) {
                // Предотвращаем прокрутку при перетаскивании
                if (isInteracting) e.preventDefault();

                mouse.x = (e.clientX/window.innerWidth)*2-1;
                mouse.y = -(e.clientY/window.innerHeight)*2+1;
                raycaster.setFromCamera(mouse, camera);

                if (isMouseDown && isInteracting && activeClip) {
                    isDragging = true;
                    if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                        activeClip.group.position.copy(intersectPoint.add(dragOffset));
                        if (activeClip.wire) activeClip.wire.updateGeometry();
                    }
                    checkTerminalHover();
                    return;
                }

                if (isMouseDown && isInteracting && activeMovable) {
                    if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                        const newPos = intersectPoint.add(dragOffset);
                        newPos.y = originalMovablePos.y;
                        activeMovable.position.copy(newPos);
                        updateAttachedClips(activeMovable);
                        updateWiresForComponent(activeMovable);
                    }
                    return;
                }

                // Если ничего не перетаскиваем, просто обновляем подсветку (hover)
                checkClipHover();
                if (!hoveredClip) checkMovableHover();
                else if (hoveredMovable) { unhighlightMovable(hoveredMovable); hoveredMovable = null; }
            }

            function onPointerUp(e) {
                if (e.button !== 0) return;
                if (isInteracting && activeClip) {
                    tryConnectWire();
                } else if (activeMovable) {
                    isDraggingMovable = false;
                    unhighlightMovable(activeMovable);
                    activeMovable = null;
                    checkCircuit();
                }
                isMouseDown = false;
                isDragging = false;
                isInteracting = false;
                if (activeClip) { activeClip.unhighlight(); activeClip = null; }
                controls.enabled = true;
                // Скрываем подсказки, если не над зажимом
                if (!isOverClip) {
                    document.getElementById('drag-hint').style.display = 'none';
                }
                document.getElementById('drag-info').style.display = 'none';
            }

            function checkClipHover() {
                const clipParts = [];
                scene.traverse(obj => { if (obj.userData?.isClipPart) clipParts.push(obj); });
                scene.updateMatrixWorld(true);
                const intersects = raycaster.intersectObjects(clipParts, true);

                if (hoveredClip) {
                    hoveredClip.unhighlight();
                    hoveredClip = null;
                    renderer.domElement.style.cursor = 'auto';
                    isOverClip = false;
                    document.getElementById('drag-hint').style.display = 'none';
                }

                if (intersects.length && !isInteracting) {
                    let obj = intersects[0].object;
                    while (obj && !obj.userData.clipObject) obj = obj.parent;
                    if (obj?.userData.clipObject) {
                        hoveredClip = obj.userData.clipObject;
                        hoveredClip.highlight();
                        renderer.domElement.style.cursor = 'pointer';
                        isOverClip = true;
                        document.getElementById('drag-hint').style.display = 'block';
                    }
                }
            }

            function checkMovableHover() {
                const movables = [];
                scene.traverse(obj => { if (obj.userData?.movable) movables.push(obj); });
                const intersects = raycaster.intersectObjects(movables, true);
                
                if (hoveredMovable) {
                    unhighlightMovable(hoveredMovable);
                    hoveredMovable = null;
                    renderer.domElement.style.cursor = 'auto';
                }

                if (intersects.length && !isInteracting) {
                    const hitObj = intersects[0].object;
                    if (hitObj.userData.isBody || hitObj.parent?.userData?.movable) {
                        let obj = hitObj;
                        while (obj && !obj.userData.movable) obj = obj.parent;
                        if (obj) {
                            hoveredMovable = obj;
                            highlightMovable(obj);
                            renderer.domElement.style.cursor = 'move';
                        }
                    }
                }
            }

            function highlightMovable(obj) {
                obj.traverse(c => {
                    if (c.userData.isBody && c.material && c.material.emissive !== undefined) {
                        if (!originalMaterials.has(c)) originalMaterials.set(c, c.material);
                        if (Array.isArray(c.material)) {
                            c.material.forEach(m => { if (m.emissive) m.emissive = new THREE.Color(0x333333); });
                        } else {
                            c.material.emissive = new THREE.Color(0x333333);
                        }
                    }
                });
            }

            function unhighlightMovable(obj) {
                obj.traverse(c => {
                    if (c.userData.isBody && c.material && originalMaterials.has(c)) {
                        if (Array.isArray(c.material)) {
                            c.material.forEach(m => { if (m.emissive) m.emissive = new THREE.Color(0x000000); });
                        } else {
                            c.material.emissive = new THREE.Color(0x000000);
                        }
                    }
                });
            }

            function updateAttachedClips(comp) {
                const terms = [];
                comp.traverse(c => { if (c.userData?.type === 'terminal') terms.push(c); });
                terms.forEach(term => {
                    (term.userData.connectedClips || []).forEach(clip => {
                        const wp = new THREE.Vector3();
                        term.getWorldPosition(wp);
                        clip.group.position.copy(wp);
                        clip.group.position.y += 0.15;
                    });
                });
            }

            function updateWiresForComponent(comp) {
                const terms = [];
                comp.traverse(c => { if (c.userData?.type === 'terminal') terms.push(c); });
                const affected = new Set();
                terms.forEach(term => {
                    (term.userData.connectedClips || []).forEach(clip => { if (clip.wire) affected.add(clip.wire); });
                });
                affected.forEach(w => w.updateGeometry());
            }

            function checkTerminalHover() {
                const terms = [];
                scene.traverse(obj => { if (obj.userData?.type === 'terminal') terms.push(obj); });
                scene.updateMatrixWorld(true);
                const intersects = raycaster.intersectObjects(terms, true);

                if (hoveredTerminal) {
                    resetObjectHighlight(hoveredTerminal);
                    hoveredTerminal = null;
                }

                if (intersects.length) {
                    const obj = intersects[0].object;
                    if (activeClip && obj.material.color.getHex() === activeClip.color) {
                        hoveredTerminal = obj;
                        setObjectHighlight(obj);
                        renderer.domElement.style.cursor = 'pointer';
                    } else {
                        renderer.domElement.style.cursor = 'not-allowed';
                    }
                } else {
                    renderer.domElement.style.cursor = 'move';
                }
            }

            function setObjectHighlight(obj) {
                if (!originalMaterials.has(obj)) originalMaterials.set(obj, obj.material);
                obj.material.emissive = new THREE.Color(0x333333);
            }
            function resetObjectHighlight(obj) {
                if (originalMaterials.has(obj)) obj.material.emissive = new THREE.Color(0x000000);
            }

            function tryConnectWire() {
                if (hoveredTerminal && activeClip) {
                    const isOccupied = !hoveredTerminal.userData.label.startsWith('battery_') && hoveredTerminal.userData.connectedClips.length > 0;
                    if (isOccupied) {
                        activeClip.group.position.copy(activeClip.homePos);
                        if (activeClip.wire) activeClip.wire.updateGeometry();
                        if (activeClip.connectedTerminal) {
                            const old = activeClip.connectedTerminal;
                            const idx = old.userData.connectedClips.indexOf(activeClip);
                            if (idx !== -1) old.userData.connectedClips.splice(idx,1);
                            activeClip.connectedTerminal = null;
                            activeClip.connected = false;
                        }
                    } else {
                        if (activeClip.connectedTerminal) {
                            const old = activeClip.connectedTerminal;
                            const idx = old.userData.connectedClips.indexOf(activeClip);
                            if (idx !== -1) old.userData.connectedClips.splice(idx,1);
                        }
                        activeClip.connectToTerminal(hoveredTerminal);
                        hoveredTerminal.userData.connectedClips.push(activeClip);
                    }
                } else {
                    activeClip.group.position.copy(activeClip.homePos);
                    if (activeClip.wire) activeClip.wire.updateGeometry();
                    if (activeClip.connectedTerminal) {
                        const old = activeClip.connectedTerminal;
                        const idx = old.userData.connectedClips.indexOf(activeClip);
                        if (idx !== -1) old.userData.connectedClips.splice(idx,1);
                        activeClip.connectedTerminal = null;
                        activeClip.connected = false;
                    }
                }
                resetDragState();
            }

            function resetDragState() {
                if (hoveredTerminal) { resetObjectHighlight(hoveredTerminal); hoveredTerminal = null; }
                isDragging = false;
                document.getElementById('drag-hint').style.display = isOverClip ? 'block' : 'none';
                document.getElementById('drag-info').style.display = 'none';
                renderer.domElement.style.cursor = isOverClip ? 'pointer' : 'auto';
                checkCircuit();
            }

            function checkCircuit() {
                document.getElementById('lamp-status').textContent = 'Выкл';
                document.getElementById('lamp-status').className = 'off';
                document.getElementById('relay-status').textContent = 'Не активировано';
                lampLight.intensity = 0;
                if (relayLight) relayLight.visible = false;

                const terms = {};
                scene.traverse(obj => { if (obj.userData?.type === 'terminal' && obj.userData.label) terms[obj.userData.label] = obj; });

                const batP = terms['battery_plus'], batM = terms['battery_minus'];
                const lampP = terms['lamp_plus'], lampM = terms['lamp_minus'];
                const r85 = terms['relay_85'], r86 = terms['relay_86'], r87 = terms['relay_87'], r30 = terms['relay_30'];

                if (checkConnection(batP, lampP) && checkConnection(batM, lampM)) {
                    document.getElementById('connection-status').innerHTML = 'Цепь замкнута правильно (прямое подключение)';
                    document.getElementById('connection-status').className = 'status on';
                    document.getElementById('lamp-status').textContent = 'Вкл';
                    document.getElementById('lamp-status').className = 'on';
                    lampLight.intensity = 1;
                    updateCircuitDiagram('direct');
                    return;
                }

                if (checkConnection(batP, r86) && checkConnection(batP, r30) && checkConnection(batM, r85) && checkConnection(batM, lampM) && checkConnection(lampP, r87)) {
                    document.getElementById('connection-status').innerHTML = 'Цепь замкнута правильно (через реле)';
                    document.getElementById('connection-status').className = 'status on';
                    document.getElementById('relay-status').textContent = 'Активировано';
                    document.getElementById('lamp-status').textContent = 'Вкл';
                    document.getElementById('lamp-status').className = 'on';
                    if (relayLight) relayLight.visible = true;
                    lampLight.intensity = 1;
                    updateCircuitDiagram('relay');
                } else {
                    document.getElementById('connection-status').innerHTML = 'Цепь не замкнута или подключена неправильно';
                    document.getElementById('connection-status').className = 'status off';
                    updateCircuitDiagram('none');
                }
            }

            function checkConnection(a, b) {
                if (!a || !b) return false;
                for (let clip of a.userData.connectedClips) {
                    if (clip.wire) {
                        const other = clip.wire.startClip === clip ? clip.wire.endClip : clip.wire.startClip;
                        if (other.connectedTerminal === b) return true;
                    }
                }
                return false;
            }

            function updateCircuitDiagram(type) {
                const div = document.getElementById('circuit-image');
                if (type === 'direct') div.innerHTML = '<div style="color:#2ecc71; font-weight:bold;">✓ Прямое подключение</div><div style="font-size:12px;">Аккумулятор → Лампа</div>';
                else if (type === 'relay') div.innerHTML = '<div style="color:#2ecc71; font-weight:bold;">✓ Подключение через реле</div><div style="font-size:12px;">Аккумулятор → Реле → Лампа</div>';
                else div.innerHTML = '<div style="color:#e74c3c; font-weight:bold;">✗ Нет подключения</div><div style="font-size:12px;">Подключите компоненты правильно</div>';
            }

            function resetConnections() {
                scene.traverse(obj => { if (obj.userData?.type === 'terminal' && obj.userData.connectedClips) obj.userData.connectedClips = []; });
                clips.forEach(c => c.disconnect());
                checkCircuit();
            }

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            window.addEventListener('load', init);
            window.addEventListener('resize', ()=>{
                if (camera && renderer) {
                    camera.aspect = window.innerWidth/window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
        })();
    </script>
</body>
</html>